<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Block Blast Pro</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
      /* Prevent scrolling while playing */
      body {
        overscroll-behavior: none;
        touch-action: none;
        user-select: none;
        -webkit-user-select: none;
        font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      }
      
      /* Custom Animations */
      @keyframes pop {
        0% { transform: scale(0.5); opacity: 0; }
        100% { transform: scale(1); opacity: 1; }
      }
      @keyframes clear-flash {
        0% { background-color: rgba(255, 255, 255, 0.8); transform: scale(1.05); }
        100% { background-color: transparent; transform: scale(1); }
      }
      @keyframes shake-light {
        0%, 100% { transform: translateX(0); }
        25% { transform: translateX(-2px) rotate(-1deg); }
        75% { transform: translateX(2px) rotate(1deg); }
      }
      @keyframes shake-medium {
        0%, 100% { transform: translateX(0); }
        20% { transform: translateX(-4px) rotate(-2deg); }
        40% { transform: translateX(4px) rotate(2deg); }
        60% { transform: translateX(-4px) rotate(-2deg); }
        80% { transform: translateX(4px) rotate(2deg); }
      }
      @keyframes shake-heavy {
        0%, 100% { transform: translate(0, 0); }
        10% { transform: translate(-5px, -5px) rotate(-3deg); }
        30% { transform: translate(5px, 5px) rotate(3deg); }
        50% { transform: translate(-5px, 5px) rotate(-3deg); }
        70% { transform: translate(5px, -5px) rotate(3deg); }
        90% { transform: translate(-2px, 2px) rotate(0); }
      }
      @keyframes text-pop {
        0% { transform: scale(0.5) translateY(20px); opacity: 0; }
        50% { transform: scale(1.5) translateY(-20px); opacity: 1; }
        100% { transform: scale(1) translateY(-40px); opacity: 0; }
      }
      @keyframes score-bump {
        0% { transform: scale(1); }
        50% { transform: scale(1.5); color: #fbbf24; }
        100% { transform: scale(1); }
      }
      
      .animate-pop { animation: pop 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; }
      .animate-clear { animation: clear-flash 0.3s ease-out forwards; }
      .shake-light { animation: shake-light 0.3s ease-in-out; }
      .shake-medium { animation: shake-medium 0.4s ease-in-out; }
      .shake-heavy { animation: shake-heavy 0.5s ease-in-out; }
      .text-popup { animation: text-pop 1s ease-out forwards; }
      .score-bump { animation: score-bump 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
    </style>

    <script type="importmap">
      {
        "imports": {
          "react": "https://esm.sh/react@18.3.1",
          "react-dom/client": "https://esm.sh/react-dom@18.3.1/client",
          "lucide-react": "https://esm.sh/lucide-react@0.428.0"
        }
      }
    </script>
  </head>
  <body class="bg-slate-900 text-white overflow-hidden">
    <div id="root"></div>

    <script type="module">
      import React, { useState, useEffect, useRef, useCallback } from 'react';
      import ReactDOM from 'react-dom/client';
      import { 
        Play, Pause, RotateCcw, Volume2, VolumeX, Home, Bomb, 
        ShoppingCart, Calendar, CheckCircle, Lock, Coins, 
        Loader2, Heart, History, Trash2 
      } from 'lucide-react';

      // ==========================================
      // CONSTANTS & TYPES (Simulated)
      // ==========================================

      const GRID_SIZE = 8;
      const INITIAL_BOMB_TIMER = 9;
      const DAILY_LOGIN_REWARD = 100;
      const REVIVE_COST = 50;
      const COINS_PER_100_SCORE = 2;

      // Enums as Objects
      const GameMode = {
        CLASSIC: 'CLASSIC',
        ADVENTURE: 'ADVENTURE',
      };

      const GameState = {
        MENU: 'MENU',
        PLAYING: 'PLAYING',
        PAUSED: 'PAUSED',
        GAME_OVER: 'GAME_OVER',
      };

      const QuestType = {
        PLAY_GAMES: 'PLAY_GAMES',
        SCORE_POINTS: 'SCORE_POINTS',
        CLEAR_LINES: 'CLEAR_LINES',
      };

      // Styles Data
      const STYLES = {
        'default': {
          id: 'default',
          name: 'Классика',
          price: 0,
          description: 'Стандартный яркий стиль',
          previewColor: '#3b82f6',
          palette: [
            '#ef4444', // red-500
            '#f97316', // orange-500
            '#eab308', // yellow-500
            '#22c55e', // green-500
            '#06b6d4', // cyan-500
            '#3b82f6', // blue-500
            '#a855f7', // purple-500
            '#ec4899', // pink-500
          ]
        },
        'gold': {
          id: 'gold',
          name: 'Роскошь',
          price: 50,
          description: 'Премиальный золотой стиль',
          previewColor: '#d97706',
          palette: [
            '#78350f', // amber-900
            '#92400e', // amber-800
            '#b45309', // amber-700
            '#d97706', // amber-600
            '#f59e0b', // amber-500
            '#fbbf24', // amber-400
            '#fcd34d', // amber-300
            '#451a03', // amber-950
          ]
        }
      };

      // Quest Templates
      const QUEST_TEMPLATES = [
        { id: 'q1', type: QuestType.PLAY_GAMES, target: 3, reward: 50, description: 'Сыграть 3 игры' },
        { id: 'q2', type: QuestType.SCORE_POINTS, target: 1000, reward: 100, description: 'Набрать 1000 очков' },
        { id: 'q3', type: QuestType.CLEAR_LINES, target: 20, reward: 75, description: 'Очистить 20 линий' },
      ];

      // Shape Definitions
      const RAW_SHAPES = [
        [[1]], // Dot
        [[1, 1]], // 2-Line H
        [[1], [1]], // 2-Line V
        [[1, 1, 1]], // 3-Line H
        [[1], [1], [1]], // 3-Line V
        [[1, 1, 1, 1]], // 4-Line H
        [[1], [1], [1], [1]], // 4-Line V
        [[1, 1], [1, 1]], // Square
        [[1, 0], [1, 0], [1, 1]], // L
        [[0, 1], [0, 1], [1, 1]], // J
        [[1, 1, 1], [0, 1, 0]], // T
        [[1, 1, 0], [0, 1, 1]], // Z
        [[0, 1, 1], [1, 1, 0]], // S
        [[1, 1], [1, 0]], // Small corner
        [[1, 1], [0, 1]], // Small corner inv
        [[1, 0, 0], [1, 0, 0], [1, 1, 1]], // Big L
      ];

      // Block Generator
      const generateRandomBlock = (palette = STYLES['default'].palette) => {
        const shapeIdx = Math.floor(Math.random() * RAW_SHAPES.length);
        const colorIdx = Math.floor(Math.random() * palette.length);
        return {
          id: Math.random().toString(36).substr(2, 9),
          matrix: RAW_SHAPES[shapeIdx],
          color: palette[colorIdx],
        };
      };

      // Helpers
      const createEmptyGrid = () => 
        Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(null));

      const STORAGE_KEY_HIGHSCORE = (mode) => `blockBlastBest_${mode}`;
      const STORAGE_KEY_PLAYER = 'blockBlastPlayerState_v1';

      const INITIAL_PLAYER_STATE = {
        coins: 0,
        inventory: ['default'],
        currentStyleId: 'default',
        lastLoginDate: '',
        dailyRewardClaimed: false,
        dailyQuests: [],
        lastQuestDate: '',
        transactions: [],
        stats: {
          gamesPlayed: 0,
          totalLinesCleared: 0,
          totalScore: 0
        }
      };

      // ==========================================
      // AUDIO MANAGER
      // ==========================================

      class WebAudioSoundManager {
        constructor() {
          this.ctx = null;
          this.muted = false;
          try {
            const AudioContextClass = window.AudioContext || window.webkitAudioContext;
            if (AudioContextClass) {
              this.ctx = new AudioContextClass();
            }
          } catch (e) {
            console.error("Web Audio API not supported");
          }
        }

        get isMuted() { return this.muted; }

        toggleMute() { this.muted = !this.muted; }

        playTone(freq, type, duration, startTime = 0) {
          if (this.muted || !this.ctx) return;
          if (this.ctx.state === 'suspended') this.ctx.resume();

          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();

          osc.type = type;
          osc.frequency.setValueAtTime(freq, this.ctx.currentTime + startTime);
          gain.gain.setValueAtTime(0.1, this.ctx.currentTime + startTime);
          gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + startTime + duration);

          osc.connect(gain);
          gain.connect(this.ctx.destination);

          osc.start(this.ctx.currentTime + startTime);
          osc.stop(this.ctx.currentTime + startTime + duration);
        }

        playPop() { this.playTone(400, 'sine', 0.1); }
        
        playClick() { this.playTone(800, 'triangle', 0.05); }

        playClear(combo) {
          if (this.muted || !this.ctx) return;
          const baseFreq = 400;
          for(let i = 0; i < Math.min(combo, 5); i++) {
            this.playTone(baseFreq * (1 + i * 0.25), 'sine', 0.3, i * 0.05);
          }
        }

        playGameOver() {
          if (this.muted || !this.ctx) return;
          this.playTone(300, 'sawtooth', 0.3, 0);
          this.playTone(250, 'sawtooth', 0.3, 0.2);
          this.playTone(200, 'sawtooth', 0.5, 0.4);
        }
      }

      const soundManager = new WebAudioSoundManager();

      // ==========================================
      // COMPONENTS
      // ==========================================

      // --- Block Component ---
      const Block = ({ shape, size, className, onPointerDown, style }) => {
        const rows = shape.matrix.length;
        const cols = shape.matrix[0].length;
        const width = cols * size;
        const height = rows * size;

        return (
          React.createElement("div", {
            className: `relative touch-none select-none ${className || ''}`,
            style: { width, height, ...style },
            onPointerDown: onPointerDown
          },
            shape.matrix.map((row, r) => (
              row.map((cell, c) => {
                if (!cell) return null;
                return (
                  React.createElement("div", {
                    key: `${r}-${c}`,
                    className: "absolute border border-white/20 rounded-sm shadow-sm",
                    style: {
                      top: r * size,
                      left: c * size,
                      width: size,
                      height: size,
                      backgroundColor: shape.color,
                      boxShadow: 'inset 0 2px 4px rgba(255,255,255,0.3), 0 2px 4px rgba(0,0,0,0.2)'
                    }
                  })
                );
              })
            ))
          )
        );
      };

      // --- Rolling Score Component ---
      const Digit = ({ value }) => {
        return (
          React.createElement("div", { className: "relative h-8 w-5 overflow-hidden sm:h-10 sm:w-6" },
            React.createElement("div", {
              className: "absolute left-0 top-0 flex flex-col transition-transform duration-500 ease-in-out",
              style: { transform: `translateY(-${parseInt(value) * 10}%)` }
            },
              [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map((n) => (
                React.createElement("div", { key: n, className: "flex h-8 w-5 items-center justify-center sm:h-10 sm:w-6" },
                  React.createElement("span", { className: "text-3xl font-black font-mono leading-none sm:text-4xl" }, n)
                )
              ))
            )
          )
        );
      };

      const RollingScore = ({ score }) => {
        const digits = score.toString().split('');
        return (
          React.createElement("div", { className: "flex items-center justify-center overflow-hidden" },
            digits.map((digit, index) => {
              const powerOfTen = digits.length - 1 - index;
              return React.createElement(Digit, { key: powerOfTen, value: digit });
            })
          )
        );
      };

      // ==========================================
      // MAIN APP COMPONENT
      // ==========================================

      const App = () => {
        // --- Game State ---
        const [gameState, setGameState] = useState(GameState.MENU);
        const [gameMode, setGameMode] = useState(GameMode.CLASSIC);
        const [grid, setGrid] = useState(createEmptyGrid());
        const [dockBlocks, setDockBlocks] = useState([null, null, null]);
        const [score, setScore] = useState(0);
        
        // --- Player & Economy State ---
        const [playerState, setPlayerState] = useState(INITIAL_PLAYER_STATE);
        const [bestScores, setBestScores] = useState({
          [GameMode.CLASSIC]: 0,
          [GameMode.ADVENTURE]: 0
        });

        // --- UI Modals State ---
        const [activeModal, setActiveModal] = useState('NONE');
        const [isCheckingNet, setIsCheckingNet] = useState(false);
        const [netError, setNetError] = useState('');

        // --- Audio & Visuals State ---
        const [isMuted, setIsMuted] = useState(soundManager.isMuted);
        const [isGameOverAnimating, setIsGameOverAnimating] = useState(false);
        const [clearingRows, setClearingRows] = useState([]);
        const [clearingCols, setClearingCols] = useState([]);
        const [shakeClass, setShakeClass] = useState('');
        const [comboText, setComboText] = useState(null);
        const [comboCount, setComboCount] = useState(0);

        // --- Drag State ---
        const [dragBlock, setDragBlock] = useState(null);
        const [dragPos, setDragPos] = useState({ x: 0, y: 0 });

        // Refs
        const gridRef = useRef(null);
        const [cellSize, setCellSize] = useState(0);

        // --- Helpers ---
        const getCurrentStyle = () => STYLES[playerState.currentStyleId] || STYLES['default'];

        // --- Persistence & Initialization ---
        useEffect(() => {
          // Load Scores
          const classic = localStorage.getItem(STORAGE_KEY_HIGHSCORE(GameMode.CLASSIC));
          const adventure = localStorage.getItem(STORAGE_KEY_HIGHSCORE(GameMode.ADVENTURE));
          setBestScores({
            [GameMode.CLASSIC]: classic ? parseInt(classic, 10) : 0,
            [GameMode.ADVENTURE]: adventure ? parseInt(adventure, 10) : 0
          });

          // Load Player State
          const savedPlayer = localStorage.getItem(STORAGE_KEY_PLAYER);
          if (savedPlayer) {
            try {
              const parsed = JSON.parse(savedPlayer);
              const merged = { ...INITIAL_PLAYER_STATE, ...parsed };
              
              if (!merged.transactions) merged.transactions = [];

              // Check Daily Reset
              const today = new Date().toISOString().split('T')[0];
              if (merged.lastLoginDate !== today) {
                merged.dailyRewardClaimed = false;
                merged.lastLoginDate = today;
              }
              if (merged.lastQuestDate !== today) {
                merged.lastQuestDate = today;
                merged.dailyQuests = QUEST_TEMPLATES.map(t => ({ ...t, current: 0, claimed: false }));
              }
              setPlayerState(merged);
            } catch (e) {
              console.error("Failed to parse player state", e);
              setPlayerState(INITIAL_PLAYER_STATE);
            }
          } else {
            // First time initialization
            const today = new Date().toISOString().split('T')[0];
            setPlayerState({
              ...INITIAL_PLAYER_STATE,
              lastLoginDate: today,
              lastQuestDate: today,
              dailyQuests: QUEST_TEMPLATES.map(t => ({ ...t, current: 0, claimed: false }))
            });
          }
        }, []);

        useEffect(() => {
          localStorage.setItem(STORAGE_KEY_PLAYER, JSON.stringify(playerState));
        }, [playerState]);

        useEffect(() => {
          if (score > bestScores[gameMode]) {
            setBestScores(prev => ({ ...prev, [gameMode]: score }));
            localStorage.setItem(STORAGE_KEY_HIGHSCORE(gameMode), score.toString());
          }
        }, [score, gameMode, bestScores]);

        // --- Economy Helpers ---
        const addTransaction = (amount, description) => {
          const type = amount > 0 ? 'EARN' : 'SPEND';
          const newTransaction = {
            id: Date.now().toString(),
            date: Date.now(),
            amount: Math.abs(amount),
            type,
            description
          };
          setPlayerState(prev => ({
            ...prev,
            coins: prev.coins + amount,
            transactions: [newTransaction, ...prev.transactions]
          }));
        };

        const calculatePendingCoins = (currentScore) => {
          return Math.floor(currentScore / 100) * COINS_PER_100_SCORE;
        };

        const endSessionAndAwardCoins = (currentScore) => {
          const coins = calculatePendingCoins(currentScore);
          if (coins > 0) {
            addTransaction(coins, `Игра: ${currentScore} очков`);
          }
        };

        const checkInternet = async () => {
          setIsCheckingNet(true);
          setNetError('');
          try {
            await new Promise(resolve => setTimeout(resolve, 800));
            // Fake network check for demo purposes (always true unless navigator offline)
            if (!navigator.onLine) throw new Error("Проверьте интернет");
            setIsCheckingNet(false);
            return true;
          } catch (e) {
            setIsCheckingNet(false);
            setNetError('Требуется интернет!');
            return false;
          }
        };

        // --- Game Logic ---
        const startGame = (mode) => {
          soundManager.playClick();
          setGameMode(mode);
          setGrid(createEmptyGrid());
          setScore(0);
          const style = getCurrentStyle();
          setDockBlocks([
            generateRandomBlock(style.palette), 
            generateRandomBlock(style.palette), 
            generateRandomBlock(style.palette)
          ]);
          setGameState(GameState.PLAYING);
          setClearingRows([]);
          setClearingCols([]);
          setComboCount(0);
          setIsGameOverAnimating(false);
          
          setPlayerState(prev => ({
            ...prev,
            stats: { ...prev.stats, gamesPlayed: prev.stats.gamesPlayed + 1 }
          }));
          updateQuestProgress(QuestType.PLAY_GAMES, 1);
        };

        const handleRestart = () => {
          endSessionAndAwardCoins(score);
          startGame(gameMode);
        };

        const handleReturnToMenu = () => {
          endSessionAndAwardCoins(score);
          soundManager.playClick();
          setGameState(GameState.MENU);
          setIsGameOverAnimating(false);
          setActiveModal('NONE');
        };

        const updateQuestProgress = (type, amount) => {
          setPlayerState(prev => ({
            ...prev,
            dailyQuests: prev.dailyQuests.map(q => {
              if (q.type === type && !q.claimed) {
                return { ...q, current: Math.min(q.target, q.current + amount) };
              }
              return q;
            })
          }));
        };

        const togglePause = () => {
          soundManager.playClick();
          if (gameState === GameState.PLAYING) setGameState(GameState.PAUSED);
          else if (gameState === GameState.PAUSED) setGameState(GameState.PLAYING);
        };

        const toggleMute = () => {
          soundManager.toggleMute();
          setIsMuted(soundManager.isMuted);
        };

        const handleRevive = () => {
          if (playerState.coins < REVIVE_COST) return;
          soundManager.playClear(3);
          addTransaction(-REVIVE_COST, 'Возрождение');
          
          // Clear 50% randomly
          setGrid(prev => prev.map(row => row.map(cell => {
            if (!cell) return null;
            return Math.random() > 0.5 ? null : cell;
          })));

          // Reset Bombs
          if (gameMode === GameMode.ADVENTURE) {
            setGrid(prev => prev.map(row => row.map(cell => {
              if (cell && cell.isBomb) {
                return { ...cell, bombTimer: INITIAL_BOMB_TIMER };
              }
              return cell;
            })));
          }

          setGameState(GameState.PLAYING);
          setIsGameOverAnimating(false);
        };

        const handleResetProgress = () => {
          if(confirm("Вы уверены? Весь прогресс будет удален.")) {
            setPlayerState(INITIAL_PLAYER_STATE);
            localStorage.removeItem(STORAGE_KEY_PLAYER);
            localStorage.removeItem(STORAGE_KEY_HIGHSCORE(GameMode.CLASSIC));
            localStorage.removeItem(STORAGE_KEY_HIGHSCORE(GameMode.ADVENTURE));
            setBestScores({ [GameMode.CLASSIC]: 0, [GameMode.ADVENTURE]: 0 });
            alert("Прогресс сброшен.");
          }
        };

        // Resize handler
        useEffect(() => {
          const handleResize = () => {
            if (gridRef.current) {
              const width = gridRef.current.clientWidth;
              setCellSize(width / GRID_SIZE);
            }
          };
          handleResize();
          window.addEventListener('resize', handleResize);
          return () => window.removeEventListener('resize', handleResize);
        }, [gameState, activeModal]);

        const canPlace = (shape, gx, gy, currentGrid) => {
          for (let r = 0; r < shape.matrix.length; r++) {
            for (let c = 0; c < shape.matrix[r].length; c++) {
              if (shape.matrix[r][c] === 1) {
                const targetX = gx + c;
                const targetY = gy + r;
                if (
                  targetX < 0 || targetX >= GRID_SIZE ||
                  targetY < 0 || targetY >= GRID_SIZE ||
                  currentGrid[targetY][targetX] !== null
                ) {
                  return false;
                }
              }
            }
          }
          return true;
        };

        const checkGameOver = useCallback((currentGrid, currentDock) => {
          if (clearingRows.length > 0 || clearingCols.length > 0) return false;

          if (gameMode === GameMode.ADVENTURE) {
            for(let r=0; r<GRID_SIZE; r++){
              for(let c=0; c<GRID_SIZE; c++){
                const cell = currentGrid[r][c];
                if(cell?.isBomb && (cell.bombTimer !== undefined && cell.bombTimer <= 0)){
                  return true;
                }
              }
            }
          }

          const availableShapes = currentDock.filter(b => b !== null);
          if (availableShapes.length === 0) return false;

          for (const shape of availableShapes) {
            for (let y = 0; y < GRID_SIZE; y++) {
              for (let x = 0; x < GRID_SIZE; x++) {
                if (canPlace(shape, x, y, currentGrid)) return false;
              }
            }
          }
          return true;
        }, [gameMode, clearingRows, clearingCols]);

        // Drag Handlers
        const handleDragStart = (e, shape, index) => {
          if (gameState !== GameState.PLAYING || isGameOverAnimating) return;
          if (clearingRows.length > 0 || clearingCols.length > 0) return;
          
          e.preventDefault();
          e.stopPropagation();
          e.target.releasePointerCapture(e.pointerId);

          const clientX = e.clientX;
          const clientY = e.clientY;
          
          const shapeWidth = shape.matrix[0].length * cellSize;
          const shapeHeight = shape.matrix.length * cellSize;

          setDragBlock({
            shape,
            index,
            startX: clientX,
            startY: clientY,
            offsetX: -shapeWidth / 2, 
            offsetY: -shapeHeight * 1.5,
          });
          setDragPos({ x: clientX, y: clientY });
          soundManager.playPop();
        };

        useEffect(() => {
          const handleMove = (e) => {
            if (dragBlock) {
              e.preventDefault();
              setDragPos({ x: e.clientX, y: e.clientY });
            }
          };

          const handleUp = (e) => {
            if (dragBlock) {
              e.preventDefault();
              dropBlock(e.clientX, e.clientY);
            }
          };

          if (dragBlock) {
            window.addEventListener('pointermove', handleMove);
            window.addEventListener('pointerup', handleUp);
          }

          return () => {
            window.removeEventListener('pointermove', handleMove);
            window.removeEventListener('pointerup', handleUp);
          };
        }, [dragBlock, grid, dockBlocks]);

        const dropBlock = (x, y) => {
          if (!dragBlock || !gridRef.current) return;
          const rect = gridRef.current.getBoundingClientRect();
          const visualX = x + dragBlock.offsetX;
          const visualY = y + dragBlock.offsetY;
          const relX = visualX - rect.left;
          const relY = visualY - rect.top;
          const gx = Math.round(relX / cellSize);
          const gy = Math.round(relY / cellSize);

          if (canPlace(dragBlock.shape, gx, gy, grid)) {
            const newGrid = grid.map(row => [...row]);
            let cellsPlaced = 0;

            dragBlock.shape.matrix.forEach((row, r) => {
              row.forEach((val, c) => {
                if (val === 1) {
                  newGrid[gy + r][gx + c] = {
                    filled: true,
                    color: dragBlock.shape.color,
                    id: `${Date.now()}-${r}-${c}`,
                    isBomb: false
                  };
                  cellsPlaced++;
                }
              });
            });

            // Adventure Logic
            if (gameMode === GameMode.ADVENTURE && Math.random() < 0.2) {
              const possibleCoords = [];
              dragBlock.shape.matrix.forEach((row, r) => {
                row.forEach((val, c) => {
                  if (val === 1) possibleCoords.push({r: gy + r, c: gx + c});
                });
              });
              if (possibleCoords.length > 0) {
                const rand = possibleCoords[Math.floor(Math.random() * possibleCoords.length)];
                const cell = newGrid[rand.r][rand.c];
                if (cell) {
                  cell.isBomb = true;
                  cell.bombTimer = INITIAL_BOMB_TIMER;
                }
              }
            }
            if (gameMode === GameMode.ADVENTURE) {
              for(let r=0; r<GRID_SIZE; r++){
                for(let c=0; c<GRID_SIZE; c++){
                  const cell = newGrid[r][c];
                  if (cell && cell.isBomb && cell.bombTimer !== undefined) {
                    cell.bombTimer -= 1;
                  }
                }
              }
            }

            soundManager.playPop();
            const rowsToClear = [];
            const colsToClear = [];
            for (let r = 0; r < GRID_SIZE; r++) {
              if (newGrid[r].every(cell => cell !== null)) rowsToClear.push(r);
            }
            for (let c = 0; c < GRID_SIZE; c++) {
              if (newGrid.map(row => row[c]).every(cell => cell !== null)) colsToClear.push(c);
            }

            const totalLines = rowsToClear.length + colsToClear.length;
            
            const currentStyle = getCurrentStyle();
            const newDock = [...dockBlocks];
            newDock[dragBlock.index] = null;
            if (newDock.every(b => b === null)) {
              setDockBlocks([
                generateRandomBlock(currentStyle.palette), 
                generateRandomBlock(currentStyle.palette), 
                generateRandomBlock(currentStyle.palette)
              ]);
            } else {
              setDockBlocks(newDock);
            }

            setGrid(newGrid);
            let pointsGained = cellsPlaced * 10;

            if (totalLines > 0) {
              soundManager.playClear(totalLines);
              setClearingRows(rowsToClear);
              setClearingCols(colsToClear);
              
              const newCombo = comboCount + 1;
              setComboCount(newCombo);
              
              if (totalLines >= 3) setShakeClass('shake-heavy');
              else if (totalLines === 2) setShakeClass('shake-medium');
              else setShakeClass('shake-light');

              const texts = [];
              if (totalLines === 2) texts.push("ДВОЙНОЙ!");
              else if (totalLines === 3) texts.push("ТРОЙНОЙ!");
              else if (totalLines === 4) texts.push("ЧЕТВЕРНОЙ!");
              else if (totalLines === 5) texts.push("ПЯТЕРНОЙ!");
              else if (totalLines >= 6) texts.push("ЛЕГЕНДАРНО!");
              if (newCombo > 1) {
                texts.push(`КОМБО x${newCombo}`);
              }
              
              if (texts.length > 0) {
                setComboText({ text: texts.join('\n'), id: Date.now() });
                setTimeout(() => setComboText(null), 1200);
              }

              setTimeout(() => {
                setGrid(prevGrid => {
                  const g = prevGrid.map(row => [...row]);
                  rowsToClear.forEach(r => {
                    for(let c=0; c<GRID_SIZE; c++) g[r][c] = null;
                  });
                  colsToClear.forEach(c => {
                    for(let r=0; r<GRID_SIZE; r++) g[r][c] = null;
                  });
                  return g;
                });
                setClearingRows([]);
                setClearingCols([]);
                setShakeClass('');

                const lineScore = totalLines * 100 * (totalLines > 1 ? totalLines : 1);
                const comboBonus = (newCombo - 1) * 20;
                const totalTurnScore = cellsPlaced * 10 + lineScore + comboBonus;
                
                setScore(s => s + totalTurnScore);
                
                updateQuestProgress(QuestType.CLEAR_LINES, totalLines);
                updateQuestProgress(QuestType.SCORE_POINTS, totalTurnScore);
                
                setPlayerState(prev => ({
                  ...prev,
                  stats: { 
                    ...prev.stats, 
                    totalLinesCleared: prev.stats.totalLinesCleared + totalLines,
                    totalScore: prev.stats.totalScore + totalTurnScore
                  }
                }));
              }, 300);

            } else {
              setComboCount(0);
              setScore(s => s + pointsGained);
              updateQuestProgress(QuestType.SCORE_POINTS, pointsGained);
              setPlayerState(prev => ({
                ...prev,
                stats: { ...prev.stats, totalScore: prev.stats.totalScore + pointsGained }
              }));
            }
          }
          setDragBlock(null);
        };

        useEffect(() => {
          if (gameState !== GameState.PLAYING) return;
          if (clearingRows.length > 0 || clearingCols.length > 0) return;
          if (isGameOverAnimating) return;

          if (checkGameOver(grid, dockBlocks)) {
            setIsGameOverAnimating(true);
            soundManager.playGameOver();
          }
        }, [grid, dockBlocks, gameState, checkGameOver, clearingRows, clearingCols, isGameOverAnimating]);

        useEffect(() => {
          if (isGameOverAnimating) {
            const timer = setTimeout(() => {
              setGameState(GameState.GAME_OVER);
            }, 1500);
            return () => clearTimeout(timer);
          }
        }, [isGameOverAnimating]);

        // --- Action Handlers (Shop, Quests, Login) ---
        const handleClaimDaily = async () => {
          if (playerState.dailyRewardClaimed) return;
          const online = await checkInternet();
          if (!online) return;

          soundManager.playClear(2);
          addTransaction(DAILY_LOGIN_REWARD, 'Ежедневный вход');
          setPlayerState(prev => ({ ...prev, dailyRewardClaimed: true }));
          setTimeout(() => setActiveModal('NONE'), 1000);
        };

        const handleClaimQuest = async (questId, reward) => {
          const online = await checkInternet();
          if (!online) return;

          soundManager.playClear(1);
          addTransaction(reward, 'Квест выполнен');
          setPlayerState(prev => ({
            ...prev,
            dailyQuests: prev.dailyQuests.map(q => q.id === questId ? { ...q, claimed: true } : q)
          }));
        };

        const handleBuyStyle = (style) => {
          if (playerState.coins >= style.price && !playerState.inventory.includes(style.id)) {
            soundManager.playClick();
            addTransaction(-style.price, `Покупка: ${style.name}`);
            setPlayerState(prev => ({
              ...prev,
              inventory: [...prev.inventory, style.id]
            }));
          }
        };

        const handleEquipStyle = (styleId) => {
          soundManager.playClick();
          setPlayerState(prev => ({
            ...prev,
            currentStyleId: styleId
          }));
        };

        // --- Render Helpers ---
        const renderGrid = () => {
          let ghostInfo = null;
          let previewRows = [];
          let previewCols = [];

          if (dragBlock && cellSize > 0 && gridRef.current && clearingRows.length === 0 && clearingCols.length === 0 && !isGameOverAnimating) {
            const rect = gridRef.current.getBoundingClientRect();
            const visualX = dragPos.x + dragBlock.offsetX;
            const visualY = dragPos.y + dragBlock.offsetY;
            const gx = Math.round((visualX - rect.left) / cellSize);
            const gy = Math.round((visualY - rect.top) / cellSize);
            
            if (canPlace(dragBlock.shape, gx, gy, grid)) {
              ghostInfo = { gx, gy, valid: true };
              const affectedRows = new Set();
              const affectedCols = new Set();
              const tempGrid = grid.map(r => [...r]);
              dragBlock.shape.matrix.forEach((row, r) => {
                row.forEach((val, c) => {
                  if (val === 1) {
                    tempGrid[gy + r][gx + c] = { filled: true, color: 'temp' };
                    affectedRows.add(gy + r);
                    affectedCols.add(gx + c);
                  }
                });
              });
              affectedRows.forEach(r => {
                if (tempGrid[r].every(cell => cell !== null)) previewRows.push(r);
              });
              affectedCols.forEach(c => {
                if (tempGrid.map(row => row[c]).every(cell => cell !== null)) previewCols.push(c);
              });
            }
          }

          const cells = [];
          for (let r = 0; r < GRID_SIZE; r++) {
            for (let c = 0; c < GRID_SIZE; c++) {
              const cell = grid[r][c];
              const isClearing = clearingRows.includes(r) || clearingCols.includes(c);
              const isPreviewClearing = previewRows.includes(r) || previewCols.includes(c);
              
              let isGhost = false;
              let ghostColor = '';
              if (ghostInfo && ghostInfo.valid) {
                if (r >= ghostInfo.gy && r < ghostInfo.gy + dragBlock.shape.matrix.length) {
                  const matrixR = r - ghostInfo.gy;
                  if (c >= ghostInfo.gx && c < ghostInfo.gx + dragBlock.shape.matrix[0].length) {
                    const matrixC = c - ghostInfo.gx;
                    if (dragBlock.shape.matrix[matrixR][matrixC] === 1) {
                      isGhost = true;
                      ghostColor = dragBlock.shape.color;
                    }
                  }
                }
              }

              const gameOverDelay = (r + c) * 0.05;
              const gameOverStyle = isGameOverAnimating ? {
                filter: 'grayscale(100%) brightness(0.4)',
                transform: 'scale(0.9)',
                transition: `all 0.5s ease-out ${gameOverDelay}s`
              } : {};

              cells.push(
                React.createElement("div", {
                  key: `${r}-${c}`,
                  className: `relative border border-white/5 transition-all duration-75 
                    ${isClearing ? 'animate-clear z-20' : ''} 
                    ${isPreviewClearing ? 'shadow-[0_0_15px_rgba(255,255,255,0.7)] z-10 brightness-150 border-white/40' : ''}
                  `,
                  style: {
                    width: cellSize,
                    height: cellSize,
                    backgroundColor: cell 
                      ? cell.color 
                      : (isGhost ? `${ghostColor}40` : 'transparent'),
                    ...gameOverStyle
                  }
                },
                  cell && !isClearing && React.createElement("div", { className: "absolute inset-0 shadow-[inset_0_2px_4px_rgba(255,255,255,0.3)] pointer-events-none" }),
                  isPreviewClearing && React.createElement("div", { className: "absolute inset-0 bg-white/40 pointer-events-none animate-pulse" }),
                  cell?.isBomb && React.createElement("div", { className: "absolute inset-0 flex items-center justify-center animate-pulse z-10" },
                    React.createElement(Bomb, { size: cellSize * 0.6, className: "text-white drop-shadow-md" }),
                    React.createElement("span", { className: "absolute text-white font-bold text-xs mt-1 drop-shadow-md" }, cell.bombTimer)
                  )
                )
              );
            }
          }
          return cells;
        };

        const getDockScale = (block) => {
          if (!cellSize) return 0.5;
          const shapeWidth = block.matrix[0].length * cellSize;
          const maxSlotWidth = (window.innerWidth - 32) / 3;
          return Math.min(0.55, (maxSlotWidth - 10) / shapeWidth);
        };

        // --- UI Rendering ---
        if (gameState === GameState.MENU) {
          return (
            React.createElement("div", { className: "flex flex-col items-center justify-center h-screen bg-slate-900 text-white p-4 space-y-8 relative overflow-hidden" },
              
              // Currency Display
              React.createElement("button", {
                onClick: () => setActiveModal('HISTORY'),
                className: "absolute top-4 right-4 flex items-center space-x-2 bg-slate-800/80 px-4 py-2 rounded-full shadow-lg border border-slate-700 hover:scale-105 active:scale-95 transition-all z-20"
              },
                React.createElement(Coins, { size: 20, className: "text-yellow-400" }),
                React.createElement("span", { className: "font-bold font-mono" }, playerState.coins)
              ),

              // Sidebar Buttons
              React.createElement("div", { className: "absolute left-4 top-24 flex flex-col space-y-4 z-20" },
                // Daily Login
                React.createElement("button", {
                  onClick: () => setActiveModal('DAILY'),
                  className: "relative p-3 bg-slate-800 rounded-xl border border-slate-700 shadow-lg hover:scale-110 transition-transform group"
                },
                  React.createElement(Calendar, { size: 24, className: playerState.dailyRewardClaimed ? "text-slate-400" : "text-green-400 animate-pulse" }),
                  !playerState.dailyRewardClaimed && React.createElement("span", { className: "absolute -top-1 -right-1 w-3 h-3 bg-red-500 rounded-full animate-bounce" }),
                  React.createElement("span", { className: "absolute left-full ml-2 px-2 py-1 bg-black/80 rounded text-xs whitespace-nowrap opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none" }, "Ежедневный вход")
                ),
                // Quests
                React.createElement("button", {
                  onClick: () => setActiveModal('QUESTS'),
                  className: "relative p-3 bg-slate-800 rounded-xl border border-slate-700 shadow-lg hover:scale-110 transition-transform group"
                },
                  React.createElement(CheckCircle, { size: 24, className: "text-blue-400" }),
                  playerState.dailyQuests.some(q => q.current >= q.target && !q.claimed) && React.createElement("span", { className: "absolute -top-1 -right-1 w-3 h-3 bg-red-500 rounded-full animate-bounce" }),
                  React.createElement("span", { className: "absolute left-full ml-2 px-2 py-1 bg-black/80 rounded text-xs whitespace-nowrap opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none" }, "Квесты")
                ),
                // Shop
                React.createElement("button", {
                  onClick: () => setActiveModal('SHOP'),
                  className: "p-3 bg-slate-800 rounded-xl border border-slate-700 shadow-lg hover:scale-110 transition-transform group"
                },
                  React.createElement(ShoppingCart, { size: 24, className: "text-purple-400" }),
                  React.createElement("span", { className: "absolute left-full ml-2 px-2 py-1 bg-black/80 rounded text-xs whitespace-nowrap opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none" }, "Магазин")
                )
              ),

              React.createElement("h1", { className: "text-6xl font-black tracking-tighter text-transparent bg-clip-text bg-gradient-to-br from-cyan-400 to-purple-600 drop-shadow-lg text-center leading-tight z-10" }, 
                "BLOCK", React.createElement("br"), "BLAST"
              ),

              React.createElement("div", { className: "space-y-4 w-full max-w-xs z-10" },
                React.createElement("button", {
                  onClick: () => startGame(GameMode.CLASSIC),
                  className: "w-full relative overflow-hidden py-4 bg-blue-600 hover:bg-blue-500 rounded-2xl text-xl font-bold shadow-lg shadow-blue-500/20 transform hover:scale-105 transition-all"
                },
                  React.createElement("div", { className: "absolute top-1 right-2 text-[10px] text-blue-200 opacity-80" }, `Рекорд: ${bestScores[GameMode.CLASSIC]}`),
                  "Классика"
                ),
                React.createElement("button", {
                  onClick: () => startGame(GameMode.ADVENTURE),
                  className: "w-full relative overflow-hidden py-4 bg-red-600 hover:bg-red-500 rounded-2xl text-xl font-bold shadow-lg shadow-red-500/20 transform hover:scale-105 transition-all flex items-center justify-center gap-2"
                },
                  React.createElement("div", { className: "absolute top-1 right-2 text-[10px] text-red-200 opacity-80" }, `Рекорд: ${bestScores[GameMode.ADVENTURE]}`),
                  React.createElement(Bomb, { size: 24 }), " Приключение"
                )
              ),

              React.createElement("button", {
                onClick: handleResetProgress,
                className: "absolute bottom-4 text-xs text-slate-600 hover:text-slate-400 flex items-center gap-1"
              }, React.createElement(Trash2, { size: 12 }), " Сброс прогресса (Debug)"),

              // Modals
              // DAILY
              activeModal === 'DAILY' && React.createElement("div", { className: "absolute inset-0 z-50 bg-slate-900/95 backdrop-blur-md flex flex-col items-center justify-center p-4" },
                React.createElement("div", { className: "bg-slate-800 p-6 rounded-3xl w-full max-w-sm border border-slate-700 shadow-2xl relative" },
                  React.createElement("button", { onClick: () => setActiveModal('NONE'), className: "absolute top-4 right-4 text-slate-400 hover:text-white" }, "✕"),
                  React.createElement("h2", { className: "text-2xl font-bold text-center mb-6 flex items-center justify-center gap-2" },
                    React.createElement(Calendar, { className: "text-green-400" }), " Ежедневная награда"
                  ),
                  React.createElement("div", { className: "flex flex-col items-center space-y-6" },
                    React.createElement("div", { className: "relative" },
                      React.createElement("div", { className: "absolute inset-0 bg-yellow-400/20 blur-xl rounded-full" }),
                      React.createElement(Coins, { size: 80, className: "text-yellow-400 relative z-10 drop-shadow-lg" })
                    ),
                    React.createElement("div", { className: "text-4xl font-black text-white" }, `+${DAILY_LOGIN_REWARD}`),
                    React.createElement("button", {
                      disabled: playerState.dailyRewardClaimed || isCheckingNet,
                      onClick: handleClaimDaily,
                      className: `w-full py-3 rounded-xl font-bold text-lg transition-all flex items-center justify-center gap-2 ${playerState.dailyRewardClaimed ? 'bg-slate-700 text-slate-500 cursor-not-allowed' : 'bg-green-600 hover:bg-green-500 text-white shadow-lg hover:scale-105'}`
                    },
                      isCheckingNet ? React.createElement(Loader2, { className: "animate-spin" }) : null,
                      playerState.dailyRewardClaimed ? 'Уже получено' : 'Получить'
                    ),
                    netError && React.createElement("div", { className: "text-red-400 text-sm animate-pulse" }, netError)
                  )
                )
              ),

              // QUESTS
              activeModal === 'QUESTS' && React.createElement("div", { className: "absolute inset-0 z-50 bg-slate-900/95 backdrop-blur-md flex flex-col items-center justify-center p-4" },
                React.createElement("div", { className: "bg-slate-800 p-6 rounded-3xl w-full max-w-sm border border-slate-700 shadow-2xl relative" },
                  React.createElement("button", { onClick: () => setActiveModal('NONE'), className: "absolute top-4 right-4 text-slate-400 hover:text-white" }, "✕"),
                  React.createElement("h2", { className: "text-2xl font-bold text-center mb-6 flex items-center justify-center gap-2" },
                    React.createElement(CheckCircle, { className: "text-blue-400" }), " Ежедневные квесты"
                  ),
                  React.createElement("div", { className: "space-y-4 max-h-[60vh] overflow-y-auto" },
                    playerState.dailyQuests.map(quest => 
                      React.createElement("div", { key: quest.id, className: "bg-slate-900 p-4 rounded-xl border border-slate-700" },
                        React.createElement("div", { className: "flex justify-between items-start mb-2" },
                          React.createElement("div", { className: "text-sm font-bold text-slate-200" }, quest.description),
                          React.createElement("div", { className: "flex items-center gap-1 text-yellow-400 font-mono font-bold text-sm" },
                            React.createElement(Coins, { size: 12 }), quest.reward
                          )
                        ),
                        React.createElement("div", { className: "w-full bg-slate-800 h-2 rounded-full overflow-hidden mb-3" },
                          React.createElement("div", {
                            className: "bg-blue-500 h-full transition-all duration-500",
                            style: { width: `${Math.min(100, (quest.current / quest.target) * 100)}%` }
                          })
                        ),
                        React.createElement("div", { className: "flex justify-between items-center" },
                          React.createElement("span", { className: "text-xs text-slate-500" }, `${quest.current} / ${quest.target}`),
                          React.createElement("button", {
                            disabled: quest.current < quest.target || quest.claimed || isCheckingNet,
                            onClick: () => handleClaimQuest(quest.id, quest.reward),
                            className: `px-4 py-1.5 rounded-lg text-xs font-bold transition-all flex items-center gap-1 ${quest.claimed ? 'bg-slate-800 text-slate-500' : quest.current >= quest.target ? 'bg-yellow-500 text-slate-900 hover:bg-yellow-400 hover:scale-105 shadow-md' : 'bg-slate-700 text-slate-500'}`
                          },
                            isCheckingNet && quest.current >= quest.target && !quest.claimed ? React.createElement(Loader2, { size: 12, className: "animate-spin" }) : null,
                            quest.claimed ? 'Получено' : 'Забрать'
                          )
                        )
                      )
                    )
                  ),
                  netError && React.createElement("div", { className: "text-red-400 text-center mt-4 text-sm animate-pulse" }, netError)
                )
              ),

              // SHOP
              activeModal === 'SHOP' && React.createElement("div", { className: "absolute inset-0 z-50 bg-slate-900/95 backdrop-blur-md flex flex-col items-center justify-center p-4" },
                React.createElement("div", { className: "bg-slate-800 p-6 rounded-3xl w-full max-w-sm border border-slate-700 shadow-2xl relative h-[80vh] flex flex-col" },
                  React.createElement("button", { onClick: () => setActiveModal('NONE'), className: "absolute top-4 right-4 text-slate-400 hover:text-white" }, "✕"),
                  React.createElement("div", { className: "flex justify-between items-center mb-6 pr-8" },
                    React.createElement("h2", { className: "text-2xl font-bold flex items-center gap-2" },
                      React.createElement(ShoppingCart, { className: "text-purple-400" }), " Магазин"
                    ),
                    React.createElement("div", { className: "flex items-center gap-1 bg-slate-900 px-3 py-1 rounded-full" },
                      React.createElement(Coins, { size: 16, className: "text-yellow-400" }),
                      React.createElement("span", { className: "font-mono text-sm" }, playerState.coins)
                    )
                  ),
                  React.createElement("div", { className: "flex-1 overflow-y-auto space-y-4 pr-1" },
                    Object.values(STYLES).map(style => {
                      const isOwned = playerState.inventory.includes(style.id);
                      const isEquipped = playerState.currentStyleId === style.id;
                      return React.createElement("div", { key: style.id, className: `bg-slate-900 p-4 rounded-xl border ${isEquipped ? 'border-green-500 shadow-[0_0_10px_rgba(34,197,94,0.3)]' : 'border-slate-700'} relative overflow-hidden` },
                        React.createElement("div", { className: "flex gap-4" },
                          React.createElement("div", { className: "w-20 h-20 bg-slate-800 rounded-lg flex items-center justify-center p-2 relative" },
                            React.createElement("div", { className: "grid grid-cols-2 gap-1 w-full h-full" },
                              React.createElement("div", { className: "rounded-sm", style: { backgroundColor: style.palette[0] } }),
                              React.createElement("div", { className: "rounded-sm", style: { backgroundColor: style.palette[2] } }),
                              React.createElement("div", { className: "rounded-sm", style: { backgroundColor: style.palette[5] } }),
                              React.createElement("div", { className: "rounded-sm", style: { backgroundColor: style.palette[7] } })
                            )
                          ),
                          React.createElement("div", { className: "flex-1 flex flex-col justify-between" },
                            React.createElement("div", null,
                              React.createElement("h3", { className: "font-bold text-white" }, style.name),
                              React.createElement("p", { className: "text-xs text-slate-400 leading-tight mt-1" }, style.description)
                            ),
                            React.createElement("div", { className: "mt-3 flex justify-end" },
                              isOwned 
                              ? React.createElement("button", {
                                  onClick: () => handleEquipStyle(style.id),
                                  disabled: isEquipped,
                                  className: `px-4 py-1.5 rounded-lg text-xs font-bold transition-all ${isEquipped ? 'bg-green-900/50 text-green-400 border border-green-500/50 cursor-default' : 'bg-slate-700 hover:bg-slate-600 text-white'}`
                                }, isEquipped ? 'Выбрано' : 'Выбрать')
                              : React.createElement("button", {
                                  onClick: () => handleBuyStyle(style),
                                  disabled: playerState.coins < style.price,
                                  className: `px-4 py-1.5 rounded-lg text-xs font-bold transition-all flex items-center gap-1 ${playerState.coins >= style.price ? 'bg-yellow-600 hover:bg-yellow-500 text-white shadow-md' : 'bg-slate-800 text-slate-500 cursor-not-allowed border border-slate-700'}`
                                }, 
                                  playerState.coins < style.price && React.createElement(Lock, { size: 12 }),
                                  React.createElement(Coins, { size: 12, className: playerState.coins >= style.price ? "text-yellow-200" : "" }),
                                  style.price
                                )
                            )
                          )
                        )
                      );
                    })
                  )
                )
              ),

              // HISTORY
              activeModal === 'HISTORY' && React.createElement("div", { className: "absolute inset-0 z-50 bg-slate-900/95 backdrop-blur-md flex flex-col items-center justify-center p-4" },
                React.createElement("div", { className: "bg-slate-800 p-6 rounded-3xl w-full max-w-sm border border-slate-700 shadow-2xl relative h-[70vh] flex flex-col" },
                  React.createElement("button", { onClick: () => setActiveModal('NONE'), className: "absolute top-4 right-4 text-slate-400 hover:text-white" }, "✕"),
                  React.createElement("h2", { className: "text-2xl font-bold flex items-center gap-2 mb-4" },
                    React.createElement(History, { className: "text-slate-400" }), " История"
                  ),
                  React.createElement("div", { className: "flex-1 overflow-y-auto space-y-2 pr-1" },
                    playerState.transactions.length === 0 && React.createElement("div", { className: "text-center text-slate-500 mt-10" }, "История пуста"),
                    playerState.transactions.map((tx) => 
                      React.createElement("div", { key: tx.id, className: "bg-slate-900 p-3 rounded-xl border border-slate-700 flex justify-between items-center" },
                        React.createElement("div", null,
                          React.createElement("div", { className: "font-bold text-sm text-slate-200" }, tx.description),
                          React.createElement("div", { className: "text-xs text-slate-500" }, new Date(tx.date).toLocaleTimeString())
                        ),
                        React.createElement("div", { className: `font-mono font-bold ${tx.type === 'EARN' ? 'text-green-400' : 'text-red-400'}` },
                          tx.type === 'EARN' ? '+' : '-', tx.amount
                        )
                      )
                    )
                  )
                )
              )
            )
          );
        }

        // Game Render
        return (
          React.createElement("div", { className: `flex flex-col h-screen bg-slate-900 text-white overflow-hidden ${shakeClass}` },
            
            // Header
            React.createElement("div", { className: "relative flex items-center justify-center p-4 pt-6 safe-top bg-slate-800/50 backdrop-blur-sm h-24" },
              React.createElement("div", { className: "absolute left-4 top-1/2 -translate-y-1/2 hidden sm:flex flex-col" },
                React.createElement("span", { className: "text-xs text-slate-400 uppercase font-bold tracking-wider" }, "Рекорд"),
                React.createElement("span", { className: "text-xl font-bold font-mono leading-none" }, Math.max(score, bestScores[gameMode]))
              ),
              React.createElement("div", { className: "flex flex-col items-center z-10" },
                React.createElement("span", { className: "text-xs text-slate-400 uppercase font-bold tracking-wider mb-1" }, "Счёт"),
                React.createElement(RollingScore, { score: score })
              ),
              React.createElement("div", { className: "absolute right-4 top-1/2 -translate-y-1/2" },
                React.createElement("button", { onClick: togglePause, className: "p-3 bg-slate-700 rounded-full hover:bg-slate-600 transition-colors" },
                  React.createElement(Pause, { size: 24, fill: "currentColor", className: "text-slate-200" })
                )
              )
            ),

            // Grid
            React.createElement("div", { className: "flex-1 flex items-center justify-center p-4 relative" },
              React.createElement("div", {
                ref: gridRef,
                className: "relative bg-slate-800 rounded-lg shadow-2xl overflow-hidden border-2 border-slate-700",
                style: {
                  width: '100%',
                  maxWidth: '500px',
                  aspectRatio: '1/1',
                  display: 'grid',
                  gridTemplateColumns: `repeat(${GRID_SIZE}, 1fr)`,
                  gridTemplateRows: `repeat(${GRID_SIZE}, 1fr)`,
                }
              },
                renderGrid(),
                comboText && !isGameOverAnimating && React.createElement("div", { key: comboText.id, className: "absolute inset-0 flex items-center justify-center pointer-events-none z-30 px-4" },
                  React.createElement("div", { className: "text-4xl sm:text-5xl font-black text-yellow-400 drop-shadow-[0_4px_4px_rgba(0,0,0,0.5)] text-popup stroke-black text-center whitespace-pre-line leading-tight" }, comboText.text)
                )
              )
            ),

            // Dock
            React.createElement("div", { className: "h-48 pb-8 px-4 flex items-center justify-center space-x-2 bg-slate-800/30" },
              dockBlocks.map((block, i) => 
                React.createElement("div", { key: i, className: "flex-1 flex items-center justify-center h-full relative overflow-hidden" },
                  block && React.createElement("div", {
                    className: `transition-opacity duration-200 ${dragBlock?.index === i ? 'opacity-0' : 'opacity-100'}`,
                    style: { transform: `scale(${getDockScale(block)})`, transformOrigin: 'center center' }
                  },
                    React.createElement(Block, {
                      shape: block,
                      size: cellSize || 40,
                      onPointerDown: (e) => handleDragStart(e, block, i)
                    })
                  )
                )
              )
            ),

            // Drag Layer
            dragBlock && React.createElement("div", {
              className: "fixed pointer-events-none z-50 will-change-transform",
              style: {
                left: 0,
                top: 0,
                transform: `translate(${dragPos.x + dragBlock.offsetX}px, ${dragPos.y + dragBlock.offsetY}px)`
              }
            },
              React.createElement(Block, { shape: dragBlock.shape, size: cellSize, className: "opacity-90 drop-shadow-2xl scale-110" })
            ),

            // Pause Modal
            gameState === GameState.PAUSED && React.createElement("div", { className: "absolute inset-0 z-50 bg-slate-900/90 backdrop-blur-md flex flex-col items-center justify-center space-y-6" },
              React.createElement("h2", { className: "text-4xl font-black text-white" }, "ПАУЗА"),
              React.createElement("button", { onClick: togglePause, className: "p-6 bg-green-500 rounded-full shadow-lg hover:scale-110 transition-transform" },
                React.createElement(Play, { size: 40, fill: "currentColor" })
              ),
              React.createElement("div", { className: "flex space-x-4" },
                React.createElement("button", { onClick: handleRestart, className: "p-4 bg-blue-600 rounded-full hover:bg-blue-500 shadow-lg transition-transform hover:scale-105" },
                  React.createElement(RotateCcw, { size: 24 })
                ),
                React.createElement("button", { onClick: toggleMute, className: "p-4 bg-slate-700 rounded-full hover:bg-slate-600" },
                  isMuted ? React.createElement(VolumeX, { size: 24 }) : React.createElement(Volume2, { size: 24 })
                ),
                React.createElement("button", { onClick: handleReturnToMenu, className: "p-4 bg-slate-700 rounded-full hover:bg-slate-600" },
                  React.createElement(Home, { size: 24 })
                )
              )
            ),

            // Game Over Modal
            gameState === GameState.GAME_OVER && React.createElement("div", { className: "absolute inset-0 z-50 bg-slate-900/95 backdrop-blur-md flex flex-col items-center justify-center space-y-8 animate-in fade-in duration-300" },
              React.createElement("div", { className: "text-center space-y-2" },
                React.createElement("h2", { className: "text-5xl font-black text-red-500 drop-shadow-lg leading-tight" }, "ИГРА", React.createElement("br"), "ОКОНЧЕНА"),
                React.createElement("p", { className: "text-slate-400 text-lg" }, "Повезет в следующий раз!")
              ),
              
              React.createElement("div", { className: "bg-slate-800 p-6 rounded-2xl w-64 text-center shadow-xl border border-slate-700 relative overflow-hidden" },
                React.createElement("div", { className: "text-xs uppercase text-slate-500 font-bold mb-1" }, "Итоговый счёт"),
                React.createElement("div", { className: "text-4xl font-mono font-bold text-white mb-2" }, score),
                React.createElement("div", { className: "flex items-center justify-center gap-1 text-yellow-400 font-mono text-sm bg-yellow-400/10 py-1 rounded-lg mb-4" },
                  React.createElement(Coins, { size: 14 }), `+${calculatePendingCoins(score)}`
                ),
                score >= bestScores[gameMode] && score > 0 && React.createElement("div", { className: "inline-block bg-yellow-500/20 text-yellow-400 px-3 py-1 rounded-full text-sm font-bold animate-pulse" }, "НОВЫЙ РЕКОРД!"),
                React.createElement("div", { className: "mt-2 text-xs text-slate-500" }, `Лучший: ${bestScores[gameMode]}`)
              ),

              React.createElement("div", { className: "flex flex-col space-y-3 w-64" },
                React.createElement("button", {
                  onClick: handleRevive,
                  disabled: playerState.coins < REVIVE_COST,
                  className: `w-full py-3 rounded-xl text-lg font-bold shadow-lg transform transition-all flex items-center justify-center gap-2 ${playerState.coins >= REVIVE_COST ? 'bg-gradient-to-r from-purple-600 to-pink-600 hover:scale-105 text-white' : 'bg-slate-800 text-slate-500 cursor-not-allowed border border-slate-700'}`
                },
                  React.createElement(Heart, { size: 20, className: playerState.coins >= REVIVE_COST ? "animate-pulse" : "" }),
                  React.createElement("span", { className: "flex-1 text-left" }, "Продолжить"),
                  React.createElement("div", { className: "flex items-center gap-1 text-sm bg-black/20 px-2 py-0.5 rounded" },
                    React.createElement(Coins, { size: 12 }), REVIVE_COST
                  )
                ),
                React.createElement("button", {
                  onClick: handleRestart,
                  className: "w-full py-4 bg-white text-slate-900 hover:bg-slate-200 rounded-xl text-lg font-bold shadow-lg transform hover:scale-105 transition-all flex items-center justify-center gap-2"
                },
                  React.createElement(RotateCcw, { size: 20 }), " Заново"
                ),
                React.createElement("button", {
                  onClick: handleReturnToMenu,
                  className: "w-full py-4 bg-slate-800 hover:bg-slate-700 rounded-xl text-lg font-bold shadow-lg transform hover:scale-105 transition-all"
                }, "Меню")
              )
            )
          )
        );
      };

      // ==========================================
      // MOUNT
      // ==========================================
      
      const rootElement = document.getElementById('root');
      if (!rootElement) throw new Error("Could not find root element to mount to");

      const root = ReactDOM.createRoot(rootElement);
      root.render(React.createElement(App));
    </script>
  </body>
</html>
